# Phoenix App AWS Deployment with Terraform and Ansible

This guide outlines how to deploy a Phoenix application to AWS using Terraform for infrastructure provisioning and Ansible for configuration management and deployment.

## Directory Structure

```
project/
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── security.tf
└── ansible/
    ├── inventory.ini
    ├── ansible.cfg
    ├── playbook.yml
    └── roles/
        ├── common/
        ├── elixir/
        ├── nginx/
        └── phoenix/
```

## Terraform Configuration

### variables.tf
```hcl
variable "aws_region" {
  description = "AWS region to deploy resources"
  default     = "us-east-1"
}

variable "app_name" {
  description = "Name of the application"
  default     = "comments-app"
}

variable "ec2_instance_type" {
  description = "EC2 instance type"
  default     = "t3.small"
}

variable "db_instance_class" {
  description = "RDS instance class"
  default     = "db.t3.small"
}

variable "db_name" {
  description = "Database name"
  default     = "comments_app_prod"
}

variable "db_username" {
  description = "Database username"
  sensitive   = true
}

variable "db_password" {
  description = "Database password"
  sensitive   = true
}

variable "ssh_key_name" {
  description = "SSH key name for EC2 access"
}

variable "vpc_cidr" {
  description = "CIDR block for VPC"
  default     = "10.0.0.0/16"
}
```

### main.tf
```hcl
provider "aws" {
  region = var.aws_region
}

# VPC
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  tags = {
    Name = "${var.app_name}-vpc"
  }
}

# Subnets
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "${var.aws_region}a"
  map_public_ip_on_launch = true
  tags = {
    Name = "${var.app_name}-public-subnet"
  }
}

resource "aws_subnet" "private" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.2.0/24"
  availability_zone = "${var.aws_region}b"
  tags = {
    Name = "${var.app_name}-private-subnet"
  }
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  tags = {
    Name = "${var.app_name}-igw"
  }
}

# Route Tables
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }
  tags = {
    Name = "${var.app_name}-public-rt"
  }
}

resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

# EC2 Instance
resource "aws_instance" "app_server" {
  ami                    = "ami-0c7217cdde317cfec" # Ubuntu 22.04 LTS (update as needed)
  instance_type          = var.ec2_instance_type
  key_name               = var.ssh_key_name
  subnet_id              = aws_subnet.public.id
  vpc_security_group_ids = [aws_security_group.app.id]

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  tags = {
    Name = "${var.app_name}-server"
  }
}

# RDS PostgreSQL
resource "aws_db_subnet_group" "main" {
  name       = "${var.app_name}-db-subnet-group"
  subnet_ids = [aws_subnet.private.id, aws_subnet.public.id]

  tags = {
    Name = "${var.app_name}-db-subnet-group"
  }
}

resource "aws_db_instance" "postgres" {
  identifier             = "${var.app_name}-postgres"
  allocated_storage      = 20
  storage_type           = "gp2"
  engine                 = "postgres"
  engine_version         = "14.7"
  instance_class         = var.db_instance_class
  db_name                = var.db_name
  username               = var.db_username
  password               = var.db_password
  db_subnet_group_name   = aws_db_subnet_group.main.name
  vpc_security_group_ids = [aws_security_group.db.id]
  skip_final_snapshot    = true

  tags = {
    Name = "${var.app_name}-postgres"
  }
}

# Elastic IP
resource "aws_eip" "app" {
  instance = aws_instance.app_server.id
  domain   = "vpc"
  tags = {
    Name = "${var.app_name}-eip"
  }
}
```

### security.tf
```hcl
# Security Group for EC2
resource "aws_security_group" "app" {
  name        = "${var.app_name}-app-sg"
  description = "Security group for Phoenix application"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "SSH"
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTP"
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTPS"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.app_name}-app-sg"
  }
}

# Security Group for RDS
resource "aws_security_group" "db" {
  name        = "${var.app_name}-db-sg"
  description = "Security group for RDS PostgreSQL"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port       = 5432
    to_port         = 5432
    protocol        = "tcp"
    security_groups = [aws_security_group.app.id]
    description     = "PostgreSQL from app server"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.app_name}-db-sg"
  }
}
```

### outputs.tf
```hcl
output "app_public_ip" {
  value = aws_eip.app.public_ip
}

output "app_public_dns" {
  value = aws_instance.app_server.public_dns
}

output "db_endpoint" {
  value = aws_db_instance.postgres.endpoint
}

output "db_name" {
  value = aws_db_instance.postgres.db_name
}
```

## Ansible Configuration

### ansible.cfg
```ini
[defaults]
inventory = ./inventory.ini
remote_user = ubuntu
private_key_file = ~/.ssh/your-key.pem
host_key_checking = False
roles_path = ./roles
```

### inventory.ini
This file will be generated dynamically after Terraform creates the infrastructure:

```ini
[webservers]
app ansible_host=${app_public_ip} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/your-key.pem
```

### playbook.yml
```yaml
---
- name: Configure and deploy Phoenix application
  hosts: webservers
  become: yes
  vars:
    app_name: comments-app
    phoenix_port: 4000
    db_host: "{{ lookup('env', 'DB_HOST') }}"
    db_name: "{{ lookup('env', 'DB_NAME') }}"
    db_user: "{{ lookup('env', 'DB_USER') }}"
    db_password: "{{ lookup('env', 'DB_PASSWORD') }}"
    app_secret_key_base: "{{ lookup('env', 'SECRET_KEY_BASE') }}"
    erlang_cookie: "{{ lookup('env', 'ERLANG_COOKIE') }}"

  roles:
    - common
    - elixir
    - nginx
    - phoenix

  tasks:
    - name: Ensure system is updated
      apt:
        update_cache: yes
        upgrade: yes
```

## Ansible Roles

### roles/common/tasks/main.yml
```yaml
---
- name: Install essential packages
  apt:
    name:
      - build-essential
      - git
      - curl
      - wget
      - unzip
      - htop
      - vim
      - nodejs
      - npm
    state: present
```

### roles/elixir/tasks/main.yml
```yaml
---
- name: Add Erlang Solutions repository
  apt_repository:
    repo: deb https://packages.erlang-solutions.com/ubuntu focal contrib
    state: present
    filename: erlang-solutions

- name: Add Erlang Solutions key
  apt_key:
    url: https://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc
    state: present

- name: Update apt cache
  apt:
    update_cache: yes

- name: Install Erlang and Elixir
  apt:
    name:
      - esl-erlang
      - elixir
    state: present

- name: Install Hex package manager
  command: mix local.hex --force
  become: yes
  become_user: ubuntu

- name: Install Phoenix
  command: mix archive.install hex phx_new --force
  become: yes
  become_user: ubuntu
```

### roles/nginx/tasks/main.yml
```yaml
---
- name: Install Nginx
  apt:
    name: nginx
    state: present

- name: Create Nginx site configuration
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/sites-available/{{ app_name }}
  notify: reload nginx

- name: Enable Nginx site
  file:
    src: /etc/nginx/sites-available/{{ app_name }}
    dest: /etc/nginx/sites-enabled/{{ app_name }}
    state: link
  notify: reload nginx

- name: Remove default Nginx site
  file:
    path: /etc/nginx/sites-enabled/default
    state: absent
  notify: reload nginx

- name: Start and enable Nginx
  service:
    name: nginx
    state: started
    enabled: yes
```

### roles/nginx/templates/nginx.conf.j2
```
upstream phoenix {
    server 127.0.0.1:{{ phoenix_port }};
}

server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://phoenix;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### roles/nginx/handlers/main.yml
```yaml
---
- name: reload nginx
  service:
    name: nginx
    state: reloaded
```

### roles/phoenix/tasks/main.yml
```yaml
---
- name: Create deployment directory
  file:
    path: /opt/{{ app_name }}
    state: directory
    owner: ubuntu
    group: ubuntu
    mode: '0755'

- name: Clone application repository
  git:
    repo: https://github.com/yourusername/{{ app_name }}.git
    dest: /opt/{{ app_name }}
    version: main
  become: yes
  become_user: ubuntu

- name: Create release environment file
  template:
    src: prod.env.j2
    dest: /opt/{{ app_name }}/prod.env
    owner: ubuntu
    group: ubuntu
    mode: '0600'

- name: Install dependencies
  shell: |
    cd /opt/{{ app_name }} && \
    mix deps.get --only prod
  become: yes
  become_user: ubuntu

- name: Install Node.js dependencies
  shell: |
    cd /opt/{{ app_name }}/assets && \
    npm install
  become: yes
  become_user: ubuntu

- name: Compile assets
  shell: |
    cd /opt/{{ app_name }} && \
    mix assets.deploy
  environment:
    MIX_ENV: prod
  become: yes
  become_user: ubuntu

- name: Create release
  shell: |
    cd /opt/{{ app_name }} && \
    mix phx.gen.release && \
    MIX_ENV=prod mix release
  become: yes
  become_user: ubuntu

- name: Create systemd service
  template:
    src: phoenix.service.j2
    dest: /etc/systemd/system/{{ app_name }}.service
  notify: reload systemd

- name: Enable and start Phoenix service
  systemd:
    name: "{{ app_name }}"
    enabled: yes
    state: started
    daemon_reload: yes
```

### roles/phoenix/templates/prod.env.j2
```
export MIX_ENV=prod
export PORT={{ phoenix_port }}
export DATABASE_URL=ecto://{{ db_user }}:{{ db_password }}@{{ db_host }}/{{ db_name }}
export SECRET_KEY_BASE={{ app_secret_key_base }}
export PHX_HOST={{ ansible_host }}
export PHX_SERVER=true
```

### roles/phoenix/templates/phoenix.service.j2
```
[Unit]
Description={{ app_name }} Phoenix Application
After=network.target

[Service]
Type=simple
User=ubuntu
Group=ubuntu
WorkingDirectory=/opt/{{ app_name }}
EnvironmentFile=/opt/{{ app_name }}/prod.env
ExecStart=/opt/{{ app_name }}/_build/prod/rel/{{ app_name }}/bin/{{ app_name | replace('-', '_') }} start
ExecStop=/opt/{{ app_name }}/_build/prod/rel/{{ app_name }}/bin/{{ app_name | replace('-', '_') }} stop
Restart=on-failure
RestartSec=5
SyslogIdentifier={{ app_name }}

[Install]
WantedBy=multi-user.target
```

### roles/phoenix/handlers/main.yml
```yaml
---
- name: reload systemd
  systemd:
    daemon_reload: yes
```

## Deployment Script

Create a deployment script to tie everything together:

```bash
#!/bin/bash
set -e

# Generate a secret key base
SECRET_KEY_BASE=$(openssl rand -base64 64)
ERLANG_COOKIE=$(openssl rand -base64 32)

# Initialize Terraform
cd terraform
terraform init

# Apply Terraform configuration
terraform apply -auto-approve

# Get outputs
APP_IP=$(terraform output -raw app_public_ip)
DB_ENDPOINT=$(terraform output -raw db_endpoint)
DB_NAME=$(terraform output -raw db_name)

# Extract DB host from endpoint
DB_HOST=$(echo $DB_ENDPOINT | cut -d':' -f1)

cd ../ansible

# Generate inventory file
cat > inventory.ini << EOF
[webservers]
app ansible_host=${APP_IP} ansible_user=ubuntu
EOF

# Wait for SSH to become available
echo "Waiting for SSH to become available..."
while ! nc -z $APP_IP 22; do
  sleep 5
done

# Export environment variables for Ansible
export DB_HOST=$DB_HOST
export DB_NAME=$DB_NAME
export DB_USER=$(terraform output -raw db_username)
export DB_PASSWORD=$(terraform output -raw db_password)
export SECRET_KEY_BASE=$SECRET_KEY_BASE
export ERLANG_COOKIE=$ERLANG_COOKIE

# Run Ansible playbook
ansible-playbook playbook.yml

echo "Deployment completed successfully!"
echo "Application is available at: http://$APP_IP"
```

Make the script executable:
```
chmod +x deploy.sh
```